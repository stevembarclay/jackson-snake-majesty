<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Jackson's Neon Snake Arena</title>
    <style>
        :root {
            --neon-green: #39ff14;
            --neon-pink: #ff00ff;
            --bg-dark: #050505;
        }
        body {
            margin: 0;
            background-color: var(--bg-dark);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        /* Game Container to hold canvas and UI */
        #gameContainer {
            position: relative;
            width: 600px;
            height: 600px;
            box-shadow: 0 0 30px rgba(57, 255, 20, 0.3);
        }
        canvas {
            background-color: #000;
            display: block;
        }
        /* UI Overlays */
        #ui, #introScreen, #gameOverScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: none; /* Let clicks pass through unless it's a button */
        }
        #ui { justify-content: flex-start; padding-top: 20px; }
        
        /* Intro & Game Over specific styling */
        #introScreen, #gameOverScreen {
            background: rgba(5, 5, 5, 0.85);
            backdrop-filter: blur(5px);
            pointer-events: auto; /* Capture clicks here */
            z-index: 10;
        }
        
        h1 { margin: 0; font-size: 32px; color: var(--neon-green); text-shadow: 0 0 15px var(--neon-green); text-transform: uppercase; letter-spacing: 2px;}
        h2 { font-size: 24px; color: var(--neon-pink); text-shadow: 0 0 10px var(--neon-pink); margin-bottom: 30px;}
        p { margin: 5px 0; color: #aaa; font-weight: bold;}

        button {
            background: transparent;
            border: 2px solid var(--neon-green);
            color: var(--neon-green);
            padding: 15px 30px;
            font-size: 20px;
            font-family: inherit;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-green), inset 0 0 10px var(--neon-green);
            transition: all 0.2s;
        }
        button:hover {
            background: var(--neon-green);
            color: black;
            box-shadow: 0 0 30px var(--neon-green), inset 0 0 20px var(--neon-green);
        }
        
        /* Utility classes to hide/show screens */
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="ui" class="hidden">
            <h1 id="scoreDisplay">SCORE: 0 / 20</h1>
        </div>

        <div id="introScreen">
            <h1>NEON ARENA SNAKE</h1>
            <p>Use W A S D to move.</p>
            <p>Eat food. The arena shrinks.</p>
            <p>Get 20 points to win!</p>
            <br>
            <button id="startBtn">START GAME!</button>
        </div>
        
        <div id="gameOverScreen" class="hidden">
            <h1 id="gameOverTitle">GAME OVER</h1>
            <h2 id="gameOverReason"></h2>
            <button id="restartBtn">PLAY AGAIN</button>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    const CANVAS_SIZE = 600;
    const GRID_SIZE = 25; // Slightly bigger snake for texture details
    const GRID_COUNT = CANVAS_SIZE / GRID_SIZE;
    const WIN_SCORE = 20;
    const GAME_SPEED_MS = 110;
    
    // --- DOM ELEMENTS ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const ui = document.getElementById('ui');
    const introScreen = document.getElementById('introScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    
    canvas.width = CANVAS_SIZE;
    canvas.height = CANVAS_SIZE;

    // --- GAME STATE VARIABLES ---
    let gameState = 'INTRO'; // 'INTRO', 'PLAYING', 'GAMEOVER'
    let snake, velocity, food, score, particles, arena;
    let gameLoopInterval;

    // --- INITIALIZATION ---
    function initGame() {
        snake = [{x: Math.floor(GRID_COUNT/2), y: Math.floor(GRID_COUNT/2)}]; 
        velocity = {x: 1, y: 0}; // Start moving right
        score = 0;
        particles = [];
        arena = { minX: 0, maxX: GRID_COUNT, minY: 0, maxY: GRID_COUNT };
        scoreDisplay.innerText = `SCORE: 0 / ${WIN_SCORE}`;
        placeFood();
        gameState = 'PLAYING';
        
        // UI Cleanup
        introScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        ui.classList.remove('hidden');
        
        if(gameLoopInterval) clearInterval(gameLoopInterval);
        gameLoopInterval = setInterval(gameLoop, GAME_SPEED_MS);
    }

    // Button Event Listeners
    startBtn.addEventListener('click', initGame);
    restartBtn.addEventListener('click', initGame);

    // --- INPUT (WASD) ---
    document.addEventListener('keydown', (e) => {
        if (gameState !== 'PLAYING') return;

        // Using toLowerCase() handles both 'w' and 'W'
        switch(e.key.toLowerCase()) {
            case 'w': if (velocity.y === 0) velocity = {x: 0, y: -1}; break;
            case 's': if (velocity.y === 0) velocity = {x: 0, y: 1}; break;
            case 'a': if (velocity.x === 0) velocity = {x: -1, y: 0}; break;
            case 'd': if (velocity.x === 0) velocity = {x: 1, y: 0}; break;
        }
    });

    // --- MAIN GAME LOOP ---
    function gameLoop() {
        update();
        draw();
    }

    // --- LOGIC UPDATE ---
    function update() {
        if (gameState !== 'PLAYING') return;

        // 1. Calculate new head position
        const head = {x: snake[0].x + velocity.x, y: snake[0].y + velocity.y};

        // 2. Check Wall Collision (The shrinking arena walls)
        if (head.x < arena.minX || head.x >= arena.maxX || 
            head.y < arena.minY || head.y >= arena.maxY) {
            gameOver("CRASHED INTO THE WALL!");
            return;
        }

        // 3. Check Self Collision
        for (let i = 0; i < snake.length; i++) {
            if (head.x === snake[i].x && head.y === snake[i].y) {
                 // Ignore immediate reverse clash which is prevented by input logic
                gameOver("YOU BIT YOURSELF!");
                return;
            }
        }

        // 4. Move Snake (Add new head)
        snake.unshift(head);

        // 5. Check Food Collision
        if (head.x === food.x && head.y === food.y) {
            score++;
            scoreDisplay.innerText = `SCORE: ${score} / ${WIN_SCORE}`;
            createParticles(head.x * GRID_SIZE, head.y * GRID_SIZE, '#ff00ff');
            
            // Shrink mechanics
            if (score % 2 === 0) {
                if (Math.random() > 0.5) arena.minX++; else arena.maxX--;
            } else {
                if (Math.random() > 0.5) arena.minY++; else arena.maxY--;
            }

            // Win Condition
            if (score >= WIN_SCORE) {
                gameOver("YOU WON! AMAZING!", true);
                return;
            }
            placeFood();
        } else {
            // If no food eaten, remove tail to maintain length
            snake.pop(); 
        }

        // Update Particles
        particles.forEach((p, index) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            if (p.life <= 0) particles.splice(index, 1);
        });
    }

    // --- HELPER FUNCTIONS ---
    function placeFood() {
        let valid = false;
        while (!valid) {
            // Try placing food within current arena bounds
            food.x = Math.floor(Math.random() * (arena.maxX - arena.minX)) + arena.minX;
            food.y = Math.floor(Math.random() * (arena.maxY - arena.minY)) + arena.minY;
            // Ensure it's not inside the snake body
            valid = !snake.some(s => s.x === food.x && s.y === food.y);
        }
    }

    function createParticles(x, y, color) {
        for (let i = 0; i < 12; i++) {
            particles.push({
                x: x + GRID_SIZE/2, y: y + GRID_SIZE/2,
                vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                life: 1.0, color: color
            });
        }
    }

    function gameOver(reason, won = false) {
        gameState = 'GAMEOVER';
        clearInterval(gameLoopInterval);
        ui.classList.add('hidden');
        gameOverScreen.classList.remove('hidden');
        document.getElementById('gameOverTitle').innerText = won ? "VICTORY!" : "GAME OVER";
        document.getElementById('gameOverTitle').style.color = won ? "var(--neon-green)" : "red";
        document.getElementById('gameOverReason').innerText = reason;
    }

    // --- DRAWING ---
    function draw() {
        // 1. Clear Screen & Draw Background Grid
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        // 2. Draw The Danger Zone & Safe Zone
        const safeX = arena.minX * GRID_SIZE;
        const safeY = arena.minY * GRID_SIZE;
        const safeW = (arena.maxX - arena.minX) * GRID_SIZE;
        const safeH = (arena.maxY - arena.minY) * GRID_SIZE;
        
        // Fill safe zone slightly lighter
        ctx.fillStyle = '#111';
        ctx.fillRect(safeX, safeY, safeW, safeH);
        
        // Draw glowing red border around safe zone
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ff0000';
        ctx.strokeRect(safeX, safeY, safeW, safeH);
        ctx.shadowBlur = 0;

        // 3. Draw Snake (With texture and face!)
        snake.forEach((segment, index) => {
            drawSnakeSegment(segment, index === 0);
        });

        // 4. Draw Food
        drawFood();

        // 5. Draw Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1.0;
        });

        // 6. Draw Intro animation if state is INTRO
        if(gameState === 'INTRO') {
             drawIntroAnimation();
        }
    }

    function drawSnakeSegment(segment, isHead) {
        const x = segment.x * GRID_SIZE;
        const y = segment.y * GRID_SIZE;
        const size = GRID_SIZE;

        // Main Body Color
        ctx.fillStyle = isHead ? '#39ff14' : '#28a70f'; 
        ctx.shadowBlur = isHead ? 15 : 5;
        ctx.shadowColor = '#39ff14';
        // Draw rounded rect for segment
        ctx.beginPath();
        ctx.roundRect(x + 1, y + 1, size - 2, size - 2, 5);
        ctx.fill();
        ctx.shadowBlur = 0;

        // "Texture" - lighter center to make it look like a scale
        ctx.fillStyle = isHead ? '#7cff63' : '#40c924';
        ctx.beginPath();
        ctx.roundRect(x + 5, y + 5, size - 10, size - 10, 3);
        ctx.fill();

        // If it's the head, draw the face
        if (isHead) {
            drawFace(x, y, size);
        }
    }

    function drawFace(x, y, size) {
        ctx.fillStyle = 'white';
        let eyeSize = 4;
        let offset = 5;

        // Determine eye position based on velocity
        let eye1x, eye1y, eye2x, eye2y;

        if (velocity.x === 1) { // Moving Right
            eye1x = x + size - offset; eye1y = y + offset;
            eye2x = x + size - offset; eye2y = y + size - offset;
        } else if (velocity.x === -1) { // Moving Left
            eye1x = x + offset; eye1y = y + offset;
            eye2x = x + offset; eye2y = y + size - offset;
        } else if (velocity.y === -1) { // Moving Up
            eye1x = x + offset; eye1y = y + offset;
            eye2x = x + size - offset; eye2y = y + offset;
        } else { // Moving Down
            eye1x = x + offset; eye1y = y + size - offset;
            eye2x = x + size - offset; eye2y = y + size - offset;
        }

        // Draw whites of eyes
        ctx.beginPath(); ctx.arc(eye1x, eye1y, eyeSize, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eye2x, eye2y, eyeSize, 0, Math.PI*2); ctx.fill();
        
        // Draw pupils (black dots)
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(eye1x, eye1y, eyeSize/2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eye2x, eye2y, eyeSize/2, 0, Math.PI*2); ctx.fill();
    }

    function drawFood() {
        const cx = food.x * GRID_SIZE + GRID_SIZE / 2;
        const cy = food.y * GRID_SIZE + GRID_SIZE / 2;
        ctx.fillStyle = '#ff00ff';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ff00ff';
        ctx.beginPath();
        // Make food pulse slightly
        const pulse = Math.sin(Date.now() / 200) * 2;
        ctx.arc(cx, cy, GRID_SIZE / 2 - 4 + pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    function drawGrid() {
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_COUNT; i++) {
            ctx.beginPath(); ctx.moveTo(i * GRID_SIZE, 0); ctx.lineTo(i * GRID_SIZE, CANVAS_SIZE); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i * GRID_SIZE); ctx.lineTo(CANVAS_SIZE, i * GRID_SIZE); ctx.stroke();
        }
    }

    let introSnakeX = -GRID_SIZE;
    function drawIntroAnimation() {
        // Just a simple snake moving across the background behind the menu
        introSnakeX += 5;
        if(introSnakeX > CANVAS_SIZE) introSnakeX = -100;
        
        ctx.fillStyle = '#39ff14';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#39ff14';
        for(let i=0; i<5; i++) {
             ctx.fillRect(introSnakeX - (i*GRID_SIZE), CANVAS_SIZE/2, GRID_SIZE-2, GRID_SIZE-2);
        }
        ctx.shadowBlur = 0;
    }

    // Start loop for intro animation immediately
    setInterval(draw, GAME_SPEED_MS);

</script>
</body>
</html>
